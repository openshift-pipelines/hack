package main

import (
	"context"
	"embed"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	k "github.com/openshift-pipelines/hack/internal/konflux"
	"gopkg.in/yaml.v2"
)

var nameFieldInvalidCharPattern = regexp.MustCompile("[^a-z0-9]")

//go:embed templates/konflux/*.yaml templates/github/*/*.yaml templates/tekton/*.yaml
var templateFS embed.FS

const (
	GithubOrg           = "openshift-pipelines"
	DefaultImageSuffix  = "-rhel9"
	konfluxDir          = "./.konflux"
	gitHubDir           = ".github"
	tektonDir           = ".tekton"
	autoGeneratedHeader = "# Generated for Konflux Application {{.Name}}-{{.Version.Version}} by openshift-pipelines/hack. DO NOT EDIT\n"
)

func main() {
	dryRun := flag.Bool("dry-run", false, "Dry run (no commit, â€¦)")
	tmpDir := flag.String("dir", "/tmp/target", "folder to work in. If empty, will create a temporary one")
	flag.Parse()

	if _, err := exec.LookPath("gh"); !*dryRun && err != nil {
		log.Fatal("Couldn't find gh in your path, bailing.")
	}
	if _, err := exec.LookPath("jq"); !*dryRun && err != nil {
		log.Fatal("Couldn't find jq in your path, bailing.")
	}

	configFiles := flag.Args()

	dir := *tmpDir
	if dir == "" {
		var err error
		dir, err = os.MkdirTemp("", "update-konflux-repo")
		if err != nil {
			log.Fatal(err)
		}
	}

	for _, configFile := range configFiles {
		in, err := os.ReadFile(configFile)
		if err != nil {
			log.Fatal(err)
		}
		config := k.Config{}
		if err := yaml.UnmarshalStrict(in, &config); err != nil {
			log.Fatal(err)
		}
		for _, version := range config.Versions {
			application := k.Application{
				Config:  config,
				Name:    config.Name,
				Version: &version,
			}
			if err := cleanupAutogenerated(context.Background(), application, filepath.Join(konfluxDir, application.Name)); err != nil {
				log.Fatalln("error while cleaning up  Konflux Dir", err)
				return
			}

			if err := generateKonfluxApplication(application); err != nil {
				log.Fatalln("Error while generating KonFluxApplication", application, err)
			}
		}

		for _, resource := range config.Resources {
			in, err := os.ReadFile(filepath.Join(filepath.Dir(configFile), "repos", resource+".yaml"))
			if err != nil {
				log.Fatal(err)
			}
			repo := k.Repository{}
			if err := yaml.UnmarshalStrict(in, &repo); err != nil {
				log.Fatalf("Error while parsing config %s, Error:  %v ", resource, err)
			}
			config.Repos = append(config.Repos, repo)
		}

		fmt.Printf("Generating konflux configuration for %s\n", config.Name)
		if err := generateConfig(context.Background(), config, dir, *dryRun); err != nil {
			log.Fatal(err)
		}

	}
}

func generateConfig(ctx context.Context, config k.Config, dir string, dryRun bool) error {

	for _, repo := range config.Repos {
		if repo.Url == "" {
			repo.Url = fmt.Sprintf("https://github.com/%s/%s.git", GithubOrg, repo.Name)
		}
		repository := repo.Url

		fmt.Printf("::group:: generating konflux configuration for %s\n", repository)

		//Set Repo Defaults
		if repo.Tekton.WatchedSources == "" {
			repo.Tekton.WatchedSources = `"upstream/***".pathChanged() || ".konflux/patches/***".pathChanged() || ".konflux/rpms/***".pathChanged()`
		}

		// Clone and Checkout main branch for GitHub Workflows
		checkoutDirMain := filepath.Join(dir, repo.Name+"-main")
		if err := os.MkdirAll(checkoutDirMain, os.ModePerm); err != nil {
			return err
		}
		if err := cloneAndCheckout(ctx, repository, "main", checkoutDirMain, config); err != nil {
			return err
		}
		for _, branch := range repo.Branches {
			branch.Repository = &repo
			checkoutDir := filepath.Join(dir, repo.Name+"-"+branch.Name)
			log.Printf("Generating %s (%s) on %s in %s\n", repo.Name, repository, branch.Name, checkoutDir)

			//Create Checkout Directory
			if err := os.MkdirAll(checkoutDir, os.ModePerm); err != nil {
				return err
			}

			for _, v := range branch.Versions {
				version := config.Versions[v]
				if version.Version != v {
					continue
				}
				version.Branch = &branch
				repo.Application = k.Application{
					Config:  config,
					Name:    config.Name,
					Version: &version,
				}

				if err := generateKonfluxComponents(version, konfluxDir); err != nil {
					log.Fatal(err)
					return err
				}

				if err := cloneAndCheckout(ctx, repository, branch.Name, checkoutDir, config); err != nil {
					return err
				}
				if err := cleanupAutogenerated(ctx, repo.Application, filepath.Join(checkoutDir, tektonDir)); err != nil {
					return err
				}
				//Generate Tekton
				if err := generateTekton(version, filepath.Join(checkoutDir, tektonDir)); err != nil {
					log.Fatalln(err)
				}
				if repo.Upstream != "" {
					if err := cleanupAutogenerated(ctx, repo.Application, filepath.Join(checkoutDirMain, gitHubDir)); err != nil {
						return err
					}
					if err := generateGitHubWorkflow(branch, filepath.Join(checkoutDirMain, gitHubDir)); err != nil {
						log.Fatalln(err)
					}
				}

			}
			if !dryRun && branch.Name != "main" {
				if err := commitAndPullRequest(ctx, checkoutDir, branch.Name, config); err != nil {
					return err
				}
			}

		}
		if !dryRun {
			if err := commitAndPullRequest(ctx, checkoutDirMain, "main", config); err != nil {
				return err
			}
		}
	}
	return nil
}

func generateTekton(v k.Version, target string) error {
	log.Printf("Generate tekton manifest in %s\n", target)
	if err := os.MkdirAll(target, 0o755); err != nil {
		return err
	}

	// set defaults
	branch := v.Branch
	repo := branch.Repository

	for _, c := range repo.Components {
		err := updateComponent(&c, v)
		if err != nil {
			return err
		}
		switch repo.Tekton.EventType {
		case "pull_request":
			if err := generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
				return err
			}
		case "push":
			if err := generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
				return err
			}
		default:
			if err := generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
				return err
			}
			if err := generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
				return err
			}
		}
	}
	return nil
}

// // This function can be modified  if we want to override the fields at component level.
func updateComponent(c *k.Component, version k.Version) error {
	c.Version = version
	branch := *version.Branch
	repo := *branch.Repository
	c.Application = repo.Application
	c.Repository = repo
	c.Branch = branch

	if c.Tekton == (k.Tekton{}) {
		c.Tekton = repo.Tekton
	}
	if c.Dockerfile == "" {
		Dockerfile, err := eval(".konflux/dockerfiles/{{.Name}}.Dockerfile", c)
		if err != nil {
			return err
		}
		c.Dockerfile = Dockerfile
	}
	if c.PrefetchInput == "" {
		c.PrefetchInput = "{\"type\": \"rpm\", \"path\": \".konflux/rpms\"}"
	}
	if version.ImageSuffix != "None" {
		c.ImageSuffix = version.ImageSuffix
		if c.ImageSuffix == "" {
			c.ImageSuffix = DefaultImageSuffix
		}
	}
	// This is the case for git-init where we don't require upstream name because comet created is pipelines-git-init-rhel8
	if !c.NoImagePrefix && repo.Upstream != "" {
		c.ImagePrefix = strings.Split(repo.Upstream, "/")[1] + "-"
	}
	return nil
}

func generateKonfluxApplication(application k.Application) error {
	konfluxDir := filepath.Join(konfluxDir, hyphenize(application.Version.Version), application.Name)
	if err := generateFileFromTemplate("application.yaml", application, filepath.Join(konfluxDir, "application.yaml"), application); err != nil {
		return err
	}
	if strings.Contains(application.Name, "index") {
		if err := generateFileFromTemplate("release-tests.yaml", application, filepath.Join(konfluxDir, "release-tests.yaml"), application); err != nil {
			return err
		}

	}
	if err := generateFileFromTemplate("tests.yaml", application, filepath.Join(konfluxDir, "tests.yaml"), application); err != nil {
		return err
	}

	if application.Version.AutoRelease {
		if err := generateFileFromTemplate("role.yaml", application, filepath.Join(konfluxDir, "role.yaml"), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("service-account.yaml", application, filepath.Join(konfluxDir, "service-account.yaml"), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("release-plan.yaml", application, filepath.Join(konfluxDir, "release-plan.yaml"), application); err != nil {
			return err
		}
	}
	return nil
}
func generateKonfluxComponents(version k.Version, targetDir string) error {
	branch := version.Branch
	repo := branch.Repository
	application := repo.Application
	application.Version = &version
	konfluxDir := filepath.Join(targetDir, hyphenize(application.Version.Version), application.Name)

	log.Printf("Generate %s konflux configuration in %s\n", application.Name, konfluxDir)
	for _, c := range repo.Components {
		if err := updateComponent(&c, version); err != nil {
			return err
		}
		if err := generateFileFromTemplate("component.yaml", c, filepath.Join(konfluxDir, repo.Name, fmt.Sprintf("component-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("image.yaml", c, filepath.Join(konfluxDir, repo.Name, fmt.Sprintf("image-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
			return err
		}
	}

	return nil
}

func generateGitHubWorkflow(branch k.Branch, target string) error {
	log.Printf("Generate github manifests in %s\n", target)
	if err := os.MkdirAll(filepath.Join(target, "workflows"), 0o755); err != nil {
		return err
	}
	filename := fmt.Sprintf("update-sources-%s.yaml", branch.Name)
	if err := generateFileFromTemplate("update-sources.yaml", branch, filepath.Join(target, "workflows", filename), branch.Repository.Application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("auto-merge-upstream.yaml", branch, filepath.Join(target, "workflows", fmt.Sprintf("auto-merge-upstream-%s.yaml", branch.Name)), branch.Repository.Application); err != nil {
		return err
	}
	return nil
}

func cleanupAutogenerated(ctx context.Context, application k.Application, dir string) error {
	log.Printf("Cleaning up %s\n", dir)
	header, err := eval(autoGeneratedHeader, application)
	if err != nil {
		log.Printf("Failed to get autogenerated header: %s\n", err)
		return nil
	}
	if out, err := run(ctx, dir, "grep", "-Pzlr", header); err != nil {
		log.Printf("Couldn't grep for autogenerated content: %s, %s", err, out)
	} else {
		for _, f := range strings.Split(string(out), "\n") {
			if f == "" {
				continue
			}
			if err := os.Remove(filepath.Join(dir, f)); err != nil {
				return fmt.Errorf("couldn't remove autogenerated file %s: %w", f, err)
			}
		}
	}
	return nil
}
