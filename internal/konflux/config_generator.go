package konflux

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

func GenerateConfig(application Application, dryRun bool) error {
	if err := generateKonfluxConfig(application); err != nil {
		return err
	}
	if err := generateRepositoryConfig(application, dryRun); err != nil {
		return err
	}

	return nil
}

func generateRepositoryConfig(application Application, dryRun bool) error {
	log.Printf("Generating repository configuration")
	for _, repo := range application.Repositories {
		ctx := context.Background()
		var dir string
		var err error
		if dir, err = cloneAndCheckout(ctx, repo, filepath.Join("/tmp/konflux/", application.Config.Product)); err != nil {
			return err
		}
		if err := cleanupAutogenerated(ctx, application, dir, tektonDir); err != nil {
			return err
		}
		if application.Release.Version != "main" {
			if err := generateTektonConfig(repo, dir); err != nil {
				return err
			}
		}
		if err := generateGitHubConfig(repo, dir); err != nil {
			return err
		}

		if dryRun {
			log.Printf("Dry run enabled, not commiting changes to %s\n", application.Name)
		} else if err := commitAndPullRequest(ctx, repo, dir); err != nil {
			return err
		}
	}
	return nil

}

func generateTektonConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, tektonDir)
	log.Printf("Generate tekton config in %s\n", target)

	if err := os.MkdirAll(target, 0o755); err != nil {
		return err
	}

	for _, c := range repo.Components {
		v := c.Version
		if err := generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", hyphenize(basename(c.Repository.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", hyphenize(basename(c.Repository.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
		if err := updateDockerFiles(c, targetDir); err != nil {
			log.Printf("Error while updating docker files: %s", err)
		}
	}

	return nil
}

func generateGitHubConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, gitHubDir)
	log.Printf("Generate github manifests in %s\n", target)
	if err := os.MkdirAll(filepath.Join(target, "workflows"), 0o755); err != nil {
		return err
	}

	autoMergeTemplateFile := "auto-merge-upstream.yaml"
	updateSourcesTemplateFile := "update-sources.yaml"

	autoMergeWorkflowFile := autoMergeTemplateFile
	updateSourcesWorkflowFile := updateSourcesTemplateFile
	if repo.Branch.Name == "main" {
		_, err := run(context.Background(), ".github", "cp", "renovate.json", target)
		if err != nil {
			return err
		}
		updateSourcesTemplateFile = "update-sources-all.yaml"
		autoMergeTemplateFile = "auto-merge-upstream-all.yaml"
	}

	if repo.Upstream != "" {
		if err := generateFileFromTemplate(autoMergeTemplateFile, repo, filepath.Join(target, "workflows", autoMergeWorkflowFile), repo.Application); err != nil {
			return err
		}
		if err := generateFileFromTemplate(updateSourcesTemplateFile, repo, filepath.Join(target, "workflows", updateSourcesWorkflowFile), repo.Application); err != nil {
			return err
		}
	}

	return nil
}

func generateKonfluxConfig(application Application) error {
	if application.Release.Version == "main" {
		return nil
	}
	targetDir := filepath.Join(konfluxDir, application.Config.Product, hyphenize(application.Release.Version), application.Name)

	log.Printf("Delete Konflux dir in %s\n", targetDir)
	if err := os.RemoveAll(targetDir); err != nil {
		return err
	}

	if err := generateKonfluxApplication(application, targetDir); err != nil {
		return err
	}

	if err := generateKonfluxComponents(application, targetDir); err != nil {
		return err
	}

	return nil
}

func generateKonfluxApplication(application Application, targetDir string) error {
	if err := generateFileFromTemplate("application.yaml", application, filepath.Join(targetDir, "application.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("tests.yaml", application, filepath.Join(targetDir, "tests.yaml"), application); err != nil {
		return err
	}
	log.Printf("Create Release Tests in %s\n", targetDir)
	if strings.Contains(application.Name, "index") {
		if err := generateFileFromTemplate("release-tests.yaml", application, filepath.Join(targetDir, "release-tests.yaml"), application); err != nil {
			return err
		}
	}
	if err := generateFileFromTemplate("release-plan.yaml", application, filepath.Join(targetDir, "release-plan.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("service-account.yaml", application, filepath.Join(targetDir, "service-account.yaml"), application); err != nil {
		return err
	}
	if err := generateFileFromTemplate("role.yaml", application, filepath.Join(targetDir, "role.yaml"), application); err != nil {
		return err
	}

	return nil
}

func generateKonfluxComponents(application Application, targetDir string) error {
	log.Printf("Generate %s konflux configuration in %s\n", application.Name, targetDir)
	for _, c := range application.Components {
		componentDir := filepath.Join(targetDir, c.Repository.Name)
		if err := generateFileFromTemplate("component.yaml", c, filepath.Join(componentDir, fmt.Sprintf("component-%s-%s.yaml", c.Name, application.Release.Version)), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("image.yaml", c, filepath.Join(componentDir, fmt.Sprintf("image-%s-%s.yaml", c.Name, application.Release.Version)), application); err != nil {
			return err
		}
	}

	return nil
}

// cleanupAutogenerated removes any files in the given directory's given subdirs which are marked as autogenerated to the given Konflux application
func cleanupAutogenerated(ctx context.Context, application Application, dir string, subdirs ...string) error {
	cleanupHeader := "# Generated for Konflux Application {{.Name}}"
	for _, subdir := range subdirs {
		log.Printf("Cleaning up %s\n", subdir)
		autoGeneratedHeader, _ := Eval(cleanupHeader, application)
		if out, err := run(ctx, dir, "grep", "-rl", autoGeneratedHeader, subdir); err != nil {
			log.Printf("Couldn't grep for autogenerated content, Error: %v,  Output: %s", err, out)
		} else {
			for _, f := range strings.Split(string(out), "\n") {
				if f == "" {
					continue
				}
				if err := os.Remove(filepath.Join(dir, f)); err != nil {
					return fmt.Errorf("couldn't remove autogenerated file %s: %w", f, err)
				}
			}
		}
	}

	return nil
}

func updateDockerFiles(component Component, repoDir string) error {
	filePath := filepath.Join(repoDir, component.Dockerfile)

	// Define your dynamic updates here
	labels := map[string]string{
		"com.redhat.component": fmt.Sprintf("openshift-%s-container", component.Image),
		"name":                 fmt.Sprintf("openshift-pipelines/%s", component.Image),
		"version":              component.Version.PatchVersion,
		"maintainer":           "pipelines-extcomm@redhat.com",
		"summary":              fmt.Sprintf("Red Hat OpenShift Pipelines %s %s", component.Repository.Name, component.Name),
		"description":          fmt.Sprintf("Red Hat OpenShift Pipelines %s %s", component.Repository.Name, component.Name),
		"io.k8s.description":   fmt.Sprintf("Red Hat OpenShift Pipelines %s %s", component.Repository.Name, component.Name),
		"io.k8s.display-name":  fmt.Sprintf("Red Hat OpenShift Pipelines %s %s", component.Repository.Name, component.Name),
		"io.openshift.tags":    fmt.Sprintf("tekton,openshift,%s,%s", component.Repository.Name, component.Name),
		"cpe":                  fmt.Sprintf("cpe:/a:redhat:openshift_pipelines:%s::el9", component.Version.Version),
		// Add any others here...
	}

	return consolidateLabels(filePath, labels)
}

func consolidateLabels(path string, updates map[string]string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(content), "\n")
	allLabels := make(map[string]string)

	// Regex captures key="value", key='value', or key=value
	re := regexp.MustCompile(`([a-zA-Z0-9\._-]+)=["']?([^"'\n\\]+)["']?`)

	var nonLabelLines []string
	firstLabelIndex := -1
	inLabelBlock := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.HasPrefix(trimmed, "LABEL") {
			inLabelBlock = true
			if firstLabelIndex == -1 {
				firstLabelIndex = len(nonLabelLines) // Mark where the new block should go
			}
		}

		if inLabelBlock {
			matches := re.FindAllStringSubmatch(line, -1)
			for _, m := range matches {
				allLabels[m[1]] = m[2]
			}
			// If line doesn't end in \, the current LABEL instruction ends
			if !strings.HasSuffix(trimmed, "\\") {
				inLabelBlock = false
			}
			continue // Skip adding this line to nonLabelLines
		}

		nonLabelLines = append(nonLabelLines, line)
	}

	// Merge the updates into our collected map
	for k, v := range updates {
		allLabels[k] = v
	}

	// Build the new consolidated LABEL block
	var newLabelBlock []string
	newLabelBlock = append(newLabelBlock, "LABEL \\")

	// Sort keys so the Dockerfile output is deterministic/clean
	keys := make([]string, 0, len(allLabels))
	for k := range allLabels {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for i, k := range keys {
		suffix := " \\"
		if i == len(keys)-1 {
			suffix = "" // Last line of the block has no backslash
		}
		newLabelBlock = append(newLabelBlock, fmt.Sprintf("      %s=%q%s", k, allLabels[k], suffix))
	}

	// Reconstruct the final file content
	var finalOutput []string
	if firstLabelIndex != -1 {
		finalOutput = append(finalOutput, nonLabelLines[:firstLabelIndex]...)
		finalOutput = append(finalOutput, newLabelBlock...)
		finalOutput = append(finalOutput, nonLabelLines[firstLabelIndex:]...)
	} else {
		// If no labels existed at all, just append to the end
		finalOutput = append(nonLabelLines, newLabelBlock...)
	}

	return os.WriteFile(path, []byte(strings.Join(finalOutput, "\n")), 0644)
}
